---
title: Genome-wide analysis of heat shock response 
author: 
  - name: Peter Humburg
    affiliation: 1
address:
  - code: 1
    address: Wellcome Trust Centre for Human Genetics, University of Oxford, Roosevelt Dr., Oxford, OX3 7BN, UK
date: `r format(Sys.time(), "%a %d %b %Y")`
---

```{r, setup, include=FALSE, cache=FALSE}
library(gdata)
library(affy)
library(vsn)
library(limma)
library(scatterplot3d)
library(sparcl)
library(sva)
library(ggplot2)
library(dplyr)
library(tidyr)
library(readr)
library(illuminaHumanv3.db)
library(knitr)
library(pander)
library(reshape2)
library(ggdendro)

opts_chunk$set(autodep=TRUE)
opts_chunk$set(tidy=TRUE)
opts_chunk$set(echo=FALSE)
opts_chunk$set(cache=TRUE)
panderOptions("digits", 3)
panderOptions("table.split.table", 160)
options(figcap.prefix = "Figure", figcap.sep = ":", figcap.prefix.highlight = "**")
options(tabcap.prefix = "Table", tabcap.sep = ":", tabcap.prefix.highlight = "**")
```


```{r, functions, include=FALSE}
pcaPlot <- function(data, col, pch, ...){
        pca <- prcomp(t(data), scale=TRUE)
        scores <- as.data.frame(pca$x)
        plot(scores$PC1, scores$PC2, col=col, pch=pch, ...)
}

reshapeData <- function(data, value){
	ans <- reshape2::melt(data, id.vars="probe",
		value.name=value, variable.name="sample")
	splitLabel <- strsplit(as.character(ans$sample), "_", fixed=TRUE)
	ans$sample <- sapply(splitLabel, "[", 1)
	ans$treatment <- sapply(splitLabel, function(x) x[length(x)])
	as.tbl(ans[c("sample", "treatment", "probe", value)])
}

ibsClust <- function(genome, ...){
	dst <- spread(dplyr::select(genome, IID1, IID2, DST), IID2, DST)
	size <- nrow(dst) + 1
	labels <- c(as.character(dst$IID1[1]), names(dst)[-1])
	dst <- t(1 - as.matrix(dst[-1]))
	dst <- dst[!is.na(dst)]
	attr(dst, "Size") <- size
	attr(dst, "Labels") <- labels
	attr(dst, "Diag") <- FALSE
	attr(dst, "Upper") <- FALSE
	class(dst) <- "dist"
	
	hclust(dst, ...)
}

pcaClusterPlot <- function(data, i, j, fillColour, legend=TRUE){
    data <- data[, c("sample", paste0("PC", i), paste0("PC", j), "Sentrix_ID", "cluster")]
    names(data) <- c("sample", "x", "y", "Sentrix_ID", "cluster")
    clusters <- by(data, data$cluster, function(x) x)
    fig <- ggplot(data, aes(x=x, y=y))
    for(cl in clusters){
        ch <- chull(cl$x, cl$y)
        fig <- fig + geom_polygon(data=cl[ch,], fill=fillColour[cl$cluster[1]], alpha=0.7)
    }
    fig <- fig + geom_point(aes(colour=as.character(Sentrix_ID)), size=3) +
            theme_bw() + scale_colour_discrete("BeadChip") + xlab(paste0("PC", i)) + ylab(paste0("PC", j))
    if(!legend) fig <- fig + theme(legend.position="none")
    fig
}

# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
# author: Winston Chang ()
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

figRef <- local({
    tag <- numeric()
    created <- logical()
    used <- logical()
    function(label, caption, prefix = options("figcap.prefix"), 
        sep = options("figcap.sep"), prefix.highlight = options("figcap.prefix.highlight")) {
        i <- which(names(tag) == label)
        if (length(i) == 0) {
            i <- length(tag) + 1
            tag <<- c(tag, i)
            names(tag)[length(tag)] <<- label
            used <<- c(used, FALSE)
            names(used)[length(used)] <<- label
            created <<- c(created, FALSE)
            names(created)[length(created)] <<- label
        }
        if (!missing(caption)) {
            created[label] <<- TRUE
            paste0(prefix.highlight, prefix, " ", i, sep, prefix.highlight, 
                " ", caption)
        } else {
            used[label] <<- TRUE
            paste(prefix, tag[label])
        }
    }
})

tabRef <- local({
    tag <- numeric()
    created <- logical()
    used <- logical()
    function(label, caption, prefix = options("tabcap.prefix"), 
        sep = options("tabcap.sep"), prefix.highlight = options("tabcap.prefix.highlight")) {
        i <- which(names(tag) == label)
        if (length(i) == 0) {
            i <- length(tag) + 1
            tag <<- c(tag, i)
            names(tag)[length(tag)] <<- label
            used <<- c(used, FALSE)
            names(used)[length(used)] <<- label
            created <<- c(created, FALSE)
            names(created)[length(created)] <<- label
        }
        if (!missing(caption)) {
            created[label] <<- TRUE
            paste0(prefix.highlight, prefix, " ", i, sep, prefix.highlight, 
                " ", caption)
        } else {
            used[label] <<- TRUE
            paste(prefix, tag[label])
        }
    }
})
``` 
```{r, formats, include=FALSE}
formats <- read.dcf(file="default.pandoc", fields="t")[,1]
formats <- formats[!is.na(formats) & !grepl("html", formats)]
latexIdx <- which(formats == "latex")
if(length(latexIdx)){
	formats[latexIdx] <- "pdf"
}
url <- paste("heatshock_analysis", formats, sep=".")
```

<aside class="download">

# Downloads
## Report
`r paste0("<span title=\"Download report as ", formats, "\">[", formats, "](", url, ")</span>", collapse=", ")`

## Data

```{r linkData, cache=FALSE, results="asis"}
dataFiles <- sapply(data, linkFile, "data", "markdown")
desc <- sapply(data, "[[", "desc")
cat(paste0("<span title=\"", desc, "\">", dataFiles, "</span>", collapse=",\n"))
```

## Log files

```{r linkLogs, cache=FALSE, results="asis"}
logFiles <- sapply(logs, linkLog, "markdown")
desc <- sapply(logs, "[[", "desc")
cat(paste0("<span title=\"", desc, "\">", logFiles, "</span>", collapse=",\n"))
```
</aside>


# Introduction
The heat shock response is a highly conserved mechanism responsible for the 
maintenance of cellular function under stress. Originally identified as part of the 
response to increased environmental temperatures [@Ritossa62] heat shock proteins (HSPs) 
have since been implicated  in susceptability to infection [@Kee08], cancer risk [@Sfar10] 
and drug response [@Martin04]. Despite its obvious significance many details of the
heat shock response still remain uncertain.

Here we study the genome-wide changes to gene expression induced by heat shock in
60 HapMap cell lines from Yoruban individuals [@Gibbs10] to identify genes and pathways
involved in the human heat shock response. To further elucidate underlying mechanisms
genetic variants modulating gene expression are mapped across all relevant genes.

# Material and Methods

## Pre-processing and Quality Control

### Raw gene expression QC

```{r loadExpression, results="hide"}
rawIntensity <- readr::read_tsv("data/TPS00590_FinalReport_12Oct09.txt", skip=8, progress=FALSE)

sig.col<-seq(3, 722, 6)
det.col<-seq(8, 722, 6)

sig.data.raw <- rawIntensity[,sig.col]
det.data.raw <- rawIntensity[,det.col]

names(sig.data.raw) <- gsub(":AVG_Signal", "", names(sig.data.raw))
names(det.data.raw) <- gsub(":Detection Pval", "", names(det.data.raw))

info<-readr::read_tsv("data/YRI_sample_list_file_03NOV09.txt", 
		col_types=list("Date of Harvest"=col_date("%d.%m.%y"), 
				"Date of RNA extraction"=col_date("%d.%m.%y")))

## remove empty lines at end of file
info<-info[1:120,] 
factors <- which(sapply(info, is.factor))
for(i in factors){
	info[[i]] <- factor(as.character(info[[i]]))
}
info[["Cell Line"]] <- sub("^GM", "NA", info[["Cell Line"]])
info <- mutate(info, sample=paste(`Cell Line`, `Treatment`, sep="_"))

newNames <- paste(info[["Cell Line"]], info$Treatment, sep="_")
names(newNames)<- info[["ARRAY CODE"]]

## typo in sample ID
names(sig.data.raw)[13]<- "NM-75"
names(det.data.raw)[13]<- "NM-75"

names(sig.data.raw) <-gsub("-", "_", fixed=TRUE, names(sig.data.raw))
names(det.data.raw) <-gsub("-", "_", fixed=TRUE, names(det.data.raw)) #differing name format
names(sig.data.raw) <- newNames[names(sig.data.raw)]
names(det.data.raw) <- newNames[names(det.data.raw)]

sig.data.raw <- cbind(probe=rawIntensity$ProbeID, sig.data.raw)
det.data.raw <- cbind(probe=rawIntensity$ProbeID, det.data.raw)

sig.data.log<- cbind(probe=rawIntensity$ProbeID, log2(sig.data.raw[-1]))
```
Probe intensities for resting and stimulated cells were imported into R for further
processing together with associated meta data.

```{r excludeSetup}
exclude <- list()
exclude$sample <- character()
exclude$probe <- character()
```

```{r longData}
sig.data.long <- reshapeData(sig.data.log, "intensity")
sig.data.raw <- reshapeData(sig.data.raw, "intensity")
det.data.long <- reshapeData(det.data.raw, "p.value")
```

Annotations for all probes were obtained via the *illuminaHumanv3.db* Bioconductor
package [@Barbosa10]. Only probes that are considered to be of perfect or good
quality were taken forward for analysis. Additionally, all probes mapping to more than
one genomic location or to a location that contains a known SNP were excluded.

```{r probeQual}
annot <- illuminaHumanv3fullReannotation() 
exclude$probe <- union(exclude$probe, subset(annot, 
		!grepl("Good|Perfect", ProbeQuality) | !is.na(OverlappingSNP) | 
		!is.na(SecondMatches) | !is.na(OtherGenomicMatches) | 
		!is.na(RepeatMask))$ArrayAddress)
```


Probes were required to exhibit significant signal (detection p-value < 0.05) 
in at least seven samples and samples with less than 30% of the remaining probes 
providing significant signal were excluded (together with the paired sample).
Samples showing exceptionally low variation in probe intensities (standard deviation
of the log intensities of all retained probes below 0.7) were also removed.

```{r lowDetProbe}
detected <- tally(group_by(subset(det.data.long, p.value < 0.05), probe))
exclude$probe <- union(exclude$probe, filter(detected, n < 7)$probe)
```

```{r filterProbe}
sig.data.long <- filter(sig.data.long, !probe %in% exclude$probe)
sig.data.raw <- filter(sig.data.raw, !probe %in% exclude$probe)
det.data.long <- filter(det.data.long, !probe %in% exclude$probe)
```

```{r lowDetSample}
missingSample <- tally(group_by(filter(det.data.long, p.value > 0.05), sample, treatment))
missingSample$n <- missingSample$n/count(det.data.long, sample, treatment)$n
exclude$sample <- union(exclude$sample, filter(missingSample, n >= 0.7)$sample)
```

```{r lowSD}
sampleSD <- summarise(group_by(filter(sig.data.long, is.finite(intensity)), 
				sample, treatment), sd(intensity))
exclude$sample <- union(exclude$sample, filter(sampleSD, `sd(intensity)` < 0.7)$sample)
```

```{r filterSample}
sig.data.long <- filter(sig.data.long, !sample %in% exclude$sample)
sig.data.raw <- filter(sig.data.raw, !sample %in% exclude$sample)
det.data.long <- filter(det.data.long, !sample %in% exclude$sample)
```

After filtering `r length(unique(sig.data.long$probe))` of `r nrow(sig.data.raw)`
probes (`r format(length(unique(sig.data.long$probe))/nrow(sig.data.raw)*100, digits=2, nsmall=1)`%)
and `r length(unique(sig.data.long$sample))` samples remain. See `r figRef("densityPlot")`
for the distributions of intensities for the remaining probes in each sample. 

```{r densityPlot, cache=FALSE, fig.cap=figRef("densityPlot", "Distribution of probe intensities.")}
ggplot(sig.data.long, aes(x=intensity, colour=sample, linetype=treatment)) + 
		geom_density() + theme_bw() + guides(colour="none")
```

```{r pcaPrepare}
flt <- filter(sig.data.long, !is.finite(intensity))$probe
sig.data.filter <- full_join(spread(filter(sig.data.long, 
					treatment == "Basal" & !probe %in% flt), 
					sample, intensity)[-1],
			spread(filter(sig.data.long, treatment == "Stim" & !probe %in% flt), 
					sample, intensity)[-1],
			by="probe")
names(sig.data.filter) <- sub(".x", "_Basal", names(sig.data.filter), fixed=TRUE)
names(sig.data.filter) <- sub(".y", "_Stim", names(sig.data.filter), fixed=TRUE)

sig.pca <- prcomp(t(sig.data.filter[-1]), scale=TRUE)
sig.pc <- as.data.frame(sig.pca$x)
sig.pc$sample <- rownames(sig.pc)
sig.pc <- dplyr::select(as.tbl(sig.pc), sample, PC1, PC2)
sig.pc <- inner_join(sig.pc, info, by="sample")

cluster <- dplyr::filter(sig.pc, `Date cRNA Amplified` != "CE_29Sep09")
clusterBound <- chull(cluster$PC1, cluster$PC2) 
```

```{r pcaPlot, cache=FALSE, fig.cap=figRef("pcaPlot", "PCA plot of probe intensities by sample. Colours correspond to different BeadChips while shapes indicate different amplification dates. Samples from the two amplifications in October 2009 are clustered together (highlighted by the grey area).")}
ggplot(sig.pc, aes(x=PC1, y=PC2)) + 
     geom_polygon(data=cluster[clusterBound, ], fill="lightgrey", colour="grey") + 
     geom_point(aes( colour=as.character(Sentrix_ID), shape=`Date cRNA Amplified`), size=3) + 
     theme_bw() + scale_colour_discrete("BeadChip") + scale_shape_discrete("RNA Amplification")
```

A principle component analysis of the gene expression for the remaining samples indicates 
a clustering of samples from two RNA amplification batches in October 2009
(`r figRef("pcaPlot")`). This batch effect is noted for later correction during the analysis.

### Genotype QC

```{r sampleList, cache=FALSE}
samples <- sub("_.", "", unique(sig.data.long$sample))
sampleInfo <- readr::read_delim("data/hapmap_YRI_r23a_filtered.fam", delim=" ", 
		col_names=c("Family", "Individual", "Father", "Mother", "Sex", "Phenotype"))
keepSamples <- dplyr::filter(dplyr::select(sampleInfo, Family, Individual), Individual %in% samples)
write.table(keepSamples, file="tmp/sample.lst", quote=FALSE, col.names=FALSE, row.names=FALSE)
```

```{r plinkSNPs, engine="bash", cache=FALSE}
plink --bfile data/hapmap_YRI_r23a_filtered --out tmp/hapmap_yri.snp_flt --keep tmp/sample.lst --maf 0.1 --geno 0.1 --hwe 1e-4 --autosome --make-bed > log/hapmap_yri.snp_flt.log
```

```{r snpFilter, cache.extra=list(file.info("data/hapmap_YRI_r23a_filtered.bim")$mtime, file.info("tmp/hapmap_yri.bim")$mtime)}
totalSNPs <- R.utils::countLines("data/hapmap_YRI_r23a_filtered.bim")
remainSNPs <- R.utils::countLines("tmp/hapmap_yri.snp_flt.bim")
```

Genotype data provided by the HapMap project [@Gibbs10] was processed with Plink [@Chang15]
to restrict the data to autosomes and remove SNPs with low genotyping rate and 
and those with a minor allele frequency of less than 10% in the sample. This results
in the exclusion of `r totalSNPs - remainSNPs` of 
`r totalSNPs` SNPs (`r format((totalSNPs - remainSNPs)/totalSNPs*100, nsmall=2, digits=2)`%);

```{r plinkSample, engine="bash", cache=FALSE}
plink --bfile tmp/hapmap_yri.snp_flt --out tmp/hapmap_yri.smpl_flt --mind 0.1 --neighbour 1 3 --genome gz nudge --make-bed > log/hapmap_yri.smpl_flt.log
```

```{r nnIBS, cache=FALSE}
nnIBS <- readr::read_table("tmp/hapmap_yri.smpl_flt.nearest")
```

The IBS nearest neighbour caculation shows that the majority of samples are quite
similar with regard to the extend of genetic differences between them while a few
show markedly increased sharing of alleles (see `r figRef("nnIBS")` and `r tabRef("nnIBS")`). 
This is consistent with a population of largely unrelated individuals including a few 
individuals that are more closely related than expected. One individual (NA18913) also shows
evidence of reduced similarity with the second and third nearest neighbour.

```{r nnIBSplot, cache=FALSE, fig.cap=figRef("nnIBS", "Similarity between individuals. For each individual the similarity, in terms of IBS, to all other individuals is determined and individuals are ranked acording to this measure. From this a Z-score is computed for for each of the three closest neighbours (see the Plink [documentation](http://pngu.mgh.harvard.edu/~purcell/plink/strat.shtml#outlier) for details). Note the spikes corresponding to individuals with positive Z-scores indicating increased similarity of their genomes compared to the rest of the cohort.")}
ggplot(nnIBS, aes(x=Z, colour=as.factor(NN))) + geom_density(aes(group=NN)) + theme_bw()
```

```{r nnIBStable, cache=FALSE}
offset <- mean(filter(nnIBS, Z < 0 & NN == 1)$Z)
nnSuspect <- filter(nnIBS, (abs(Z - offset) > 2 & NN == 1) | abs(Z) > 2)
nnSuspect <- nnSuspect[order(abs(nnSuspect$Z), decreasing=TRUE), ]
set.caption(tabRef("nnIBS", 
		"Pairs of Yoruban HapMap samples with evidence of decreased or increased genetic similarity (absolute IBS-based nearest neighbour Z-score > 2)."))
pander(nnSuspect)
```

```{r loadIBD}
ibdReport <- read.table("tmp/hapmap_yri.smpl_flt.genome.gz", header=TRUE)
ibdSD <- sd(ibdReport$PI_HAT)
ibdHigh <- dplyr::filter(ibdReport, PI_HAT > 2*ibdSD)
```

A similar picture emerges if we consider the estimated proportion of IBD for all
sample pairs with `r nrow(ibdHigh)` pairs showing evidence of higher than expected
relatedness (see `r tabRef("ibdHigh")` and `r figRef("ibsDendro")` for details).

```{r selectExlusions}
pairs <- rbind(as.matrix(dplyr::select(ibdHigh, IID1, IID2)), 
		as.matrix(dplyr::select(nnSuspect, IID, IID2)))
exSample <- character()
while(length(pairs)){
	ids <- sort(table(pairs), decreasing=TRUE)
	exSample <- c(exSample, names(ids[1]))
	pairs <- pairs[!apply(pairs, 1, `%in%`, x=names(ids)[1]), , drop=FALSE]
}
if("NA19130" %in% exSample && !"NA19192" %in% exSample){
	exSample[which(exSample == "NA19130")] <- "NA19192"
}

exclude$sample <- union(exclude$sample, exSample)
```

To ensure that at most one sample of each suspect pair are included in the analysis
the samples `r pander(exSample)` are excluded.

```{r ibdHighTab}
set.caption(tabRef("ibdHigh", paste("Sample pairs with estimated proportion of IBD exceeding",
		format(2*ibdSD, nsmall=2, digits=2))))
pander(dplyr::select(ibdHigh, IID1, IID2, PI_HAT, DST, RATIO))
```

```{r ibsDendroPlot, cache=FALSE, fig.cap=figRef("ibsDendro", "Dendrogram of individuals included in study. Distances are based on identity by state. Three pairs show clear indications of increased relatedness.")}
plot(ibsClust(ibdReport), main="", xlab="IBS", sub="")
```

```{r filterSample2, ref.label="filterSample"}
```

```{r sampleList2, ref.label="sampleList", cache=FALSE}
```

```{r plinkMdsPlot, cache=FALSE, engine="bash"}
plink --bfile tmp/hapmap_yri.smpl_flt --out tmp/hapmap_yri.smpl_flt2 --keep tmp/sample.lst --cluster --mds-plot 4 --make-bed > log/hapmap_yri.smpl_flt.log
```

```{r mdsPlot, cache=FALSE, fig.cap=figRef("mds", "MDS plot of samples remaining after genotype QC.")}
mds <- read.table("tmp/hapmap_yri.smpl_flt2.mds", header=TRUE)
ggplot(mds, aes(x=C1, y=C2)) + geom_point(size=3) + theme_bw()
```

Plotting the first two MDS components of the remaining `r nrow(keepSamples)` samples
shows no further evidence for outliers (`r figRef("mds")`).

### Normalising gene expression estimates

Probe intensities were normalised with VSN [@Huber02]. A PCA plot of the initial 
VSN normalised data (`r figRef("vsnPCAcluster")`) shows clear evidence of samples
clustering by BeadChip, as well as three obvious outliers, which were removed.

```{r vsn}
sig.data.norm <- justvsn(acast(sig.data.raw, formula=probe ~ sample + treatment, 
		value.var="intensity"))
```

```{r vsnPCA}
sig.pca <- prcomp(t(sig.data.norm), scale=TRUE)
sig.pc <- as.data.frame(sig.pca$x)
sig.pc$sample <- rownames(sig.pc)
sig.pc <- dplyr::select(as.tbl(sig.pc), sample, PC1, PC2, PC3, PC4)
sig.pc <- inner_join(sig.pc, info, by="sample")
```

```{r vsnOutliers}
sig.pc <- mutate(sig.pc, outlier= sample %in% c("NA18508_Basal", "NA19201_Stim", 
			"NA19209_Stim"))
exclude$sample <- union(exclude$sample, c("NA18508", "NA19201", "NA19209"))
```

```{r vsnPCAcluster}
clusterOp1<- dplyr::filter(sig.pc, Sentrix_ID == 526786720 & !outlier)
clusterOp1Bound_1_2 <- chull(clusterOp1$PC1, clusterOp1$PC2)
clusterOp1Bound_2_3 <- chull(clusterOp1$PC2, clusterOp1$PC3)
clusterOp1Bound_1_3 <- chull(clusterOp1$PC1, clusterOp1$PC3)

clusterOp2<- dplyr::filter(sig.pc, Sentrix_ID == 526786721 & !outlier)
clusterOp2Bound_1_2 <- chull(clusterOp2$PC1, clusterOp2$PC2)
clusterOp2Bound_2_3 <- chull(clusterOp2$PC2, clusterOp2$PC3)
clusterOp2Bound_1_3 <- chull(clusterOp2$PC1, clusterOp2$PC3)
 

clusterChip1 <- dplyr::filter(sig.pc, Sentrix_ID == 536403752 & !outlier)
clusterChip1Bound_1_2 <- chull(clusterChip1$PC1, clusterChip1$PC2)
clusterChip1Bound_1_3 <- chull(clusterChip1$PC1, clusterChip1$PC3)
clusterChip1Bound_2_3 <- chull(clusterChip1$PC2, clusterChip1$PC3)

clusterChip2 <- dplyr::filter(sig.pc, Sentrix_ID %in% c(526786722, 526786736, 
				526786743, 526786749, 536403729) & !outlier)
clusterChip2Bound_1_2 <- chull(clusterChip2$PC1, clusterChip2$PC2)
clusterChip2Bound_1_3 <- chull(clusterChip2$PC1, clusterChip2$PC3)
clusterChip2Bound_2_3 <- chull(clusterChip2$PC2, clusterChip2$PC3)

clusterChip3 <- dplyr::filter(sig.pc, Sentrix_ID %in% c(536403760, 536403730) & !outlier)
clusterChip3Bound_1_2 <- chull(clusterChip3$PC1, clusterChip3$PC2)
clusterChip3Bound_1_3 <- chull(clusterChip3$PC1, clusterChip3$PC3)
clusterChip3Bound_2_3 <- chull(clusterChip3$PC2, clusterChip3$PC3)
```

```{r vsnPCAplot, cache=FALSE, fig.cap=figRef("vsnPCA", "PCA plot of normalised gene expression estimates by sample. Five clusters corresponfing to differnt sets of BeadChips are clearly visible.")}
ggplot(sig.pc, aes(x=PC1, y=PC2)) +  
	 geom_polygon(data=clusterOp1[clusterOp1Bound_1_2, ], alpha=0.7, 
	 		fill="lightgrey", colour="grey") +
	 geom_polygon(data=clusterOp2[clusterOp2Bound_1_2, ], alpha=0.7, 
	 		fill="pink", colour="red") +
	 geom_polygon(data=clusterChip1[clusterChip1Bound_1_2, ], alpha=0.7, 
	 		fill="yellow", colour="orange") +
	 geom_polygon(data=clusterChip2[clusterChip2Bound_1_2, ], alpha=0.7, 
	 		fill="lightgreen", colour="green") +
	 geom_polygon(data=clusterChip3[clusterChip3Bound_1_2, ], alpha=0.7, 
	 		fill="lightblue", colour="blue") +
	 geom_point(aes( colour=as.character(Sentrix_ID), shape=outlier), size=3) + 
     theme_bw() + scale_colour_discrete("BeadChip") + scale_shape_discrete("Outlier")
```

```{r excludeOutliers, ref.label="filterSample"}
```

```{r exclOutlGeno, ref.label="sampleList", cache=FALSE}
```

```{r vsn2, ref.label="vsn"}
```

Considering a hierarchical clustering of the remaining samples a similar grouping
of samples by BeadChip is apparent (`r figRef("exprDendro")`). However, the substantial
overlap between some of the BeadChips suggests that a more nuanced clustering may be
appropriate. To achieve this, a hierarhical clustering of samples, averaged across conditions,
is performed^[This ensures that both samples from the same individual are clustered together.].

```{r exprClust}
exprDist <- dist(t(sig.data.norm))
exprClust <- hclust(exprDist, method="ward.D")
```

```{r clustPlot, cache=FALSE, fig.cap=figRef("exprDendro2", paste("Dendrogram of gene expression samples. Colours of leaves correspond to clusters in", figRef("vsnPCA")))}
dendroData <- dendro_data(exprClust)
labels <- strsplit(as.character(dendroData$labels$label), "_")
dendroData$labels$label <- sapply(labels, "[[", 1)
dendroData$labels$treatment <- sapply(labels, "[[", 2)
dendroData$segments <- merge(dendroData$segments, dendroData$labels, by.x=c("xend", "yend"), by.y=c("x", "y"), all.x=TRUE)
dendroData$segments[is.na(dendroData$segments$treatment), "treatment"] <- "internal"
info[["Cell Line"]] <- sub("_.$", "", info[["Cell Line"]])
dendroData$segments <- merge(dendroData$segments, 
		info[info$Treatment == "Basal",c("Cell Line", "Sentrix_ID")], 
		by.x="label", by.y="Cell Line", all.x=TRUE)
dendroData$segments <- mutate(dendroData$segments, 
		cluster=ifelse(Sentrix_ID == 526786720, "1",
		ifelse(Sentrix_ID == 526786721, "2",
		ifelse(Sentrix_ID == 536403752, "3",
		ifelse(Sentrix_ID %in% c(526786722, 526786736, 
				526786743, 526786749, 536403729), "4", "5")))))
dendroData$segments$cluster[is.na(dendroData$segments$cluster)] <- "internal"
dendroData$segments <- dendroData$segments[order(dendroData$segments$xend), ] 
 
ggplot(dendroData$segments) + geom_segment(aes(x=x, y=y, xend=xend, yend=yend, linetype=treatment, colour=cluster)) + 
        scale_x_discrete(label=filter(dendroData$segments, label != "internal")$label) + 
        scale_linetype_manual(values=c(Basal="solid", Stim="dashed", internal="solid")) +
        scale_colour_manual(values=c("1"="grey", "2"="red", "3"="orange", "4"="green",
        "5"="blue", "internal"="black")) +
        theme_dendro() + theme(axis.text.x = element_text(angle=90, hjust=1))
```

```{r meanClust}
sig.data.mean <- matrix(nrow=nrow(sig.data.norm), ncol=ncol(sig.data.norm)/2)
colnames(sig.data.mean) <- sapply(strsplit(colnames(sig.data.norm)[seq(1, ncol(sig.data.norm),by=2)], "_"),"[[", 1)
for(i in 0:(ncol(sig.data.mean)-1)){
    sig.data.mean[, i+1] <- rowMeans(sig.data.norm[, c(i*2, i*2+1)+1])
}
exprDist <- dist(t(sig.data.mean))
exprClust <- hclust(exprDist, method="ward.D")
cluster <- cutree(exprClust, k=6)
```

```{r clustPlot2, cache=FALSE, fig.cap=figRef("exprDendro2", "Dendrogram of averaged gene expression samples.")}
dendroData <- dendro_data(exprClust)
dendroData$segments <- merge(dendroData$segments, dendroData$labels, by.x=c("xend", "yend"), by.y=c("x", "y"), all.x=TRUE)
info[["Cell Line"]] <- sub("_.$", "", info[["Cell Line"]])
info$cluster <- cluster[info[["Cell Line"]]]
dendroData$segments <- merge(dendroData$segments, 
        info[info$Treatment == "Basal",c("Cell Line", "Sentrix_ID", "cluster")], 
        by.x="label", by.y="Cell Line", all.x=TRUE)
dendroData$segments$cluster[is.na(dendroData$segments$cluster)] <- "internal"
dendroData$segments <- dendroData$segments[order(dendroData$segments$xend), ] 
 
ggplot(dendroData$segments) + geom_segment(aes(x=x, y=y, xend=xend, yend=yend, colour=cluster)) + 
        scale_x_discrete(label=filter(dendroData$segments, label != "internal")$label) + 
        scale_colour_manual(values=c("1"="grey", "2"="red", "3"="orange", "4"="green",
        "5"="blue", "6"="purple", "internal"="black")) +
        theme_dendro() + theme(axis.text.x = element_text(angle=90, hjust=1))
```

```{r meanPCA}
sig.pca <- prcomp(t(sig.data.mean), scale=TRUE)
sig.pc <- as.data.frame(sig.pca$x)
sig.pc$sample <- rownames(sig.pc)
sig.pc <- dplyr::select(as.tbl(sig.pc), sample, PC1, PC2, PC3, PC4)
sig.pc <- inner_join(sig.pc, info, by=c("sample" = "Cell Line"))
```

```{r meanPCAplot, cache=FALSE, fig.cap=figRef("meanPCA", "Plot of first few principle components showing clusters for averaged samples as determined by hierarchical clustering.")}
fillColour <- c("grey", "red", "orange", "green", "blue", "purple")
fig <- mapply(pcaClusterPlot, i=c(1,1,2,2), j=c(2,3,3,4), 
        MoreArgs=list(data=sig.pc, fillColour=fillColour, legend=FALSE), SIMPLIFY=FALSE)
multiplot(plotlist=fig, cols=2)
```

The resulting dendrogram was cut to produce six clusters (`r figRef("exprDendro2")` and `r figRef("meanPCA")`).
The samples were then normalised separately for each cluster and differences between groups
corrected with ComBat [@Johnson07;@SVA15], preserving differences due to heat shock
stimulation.

```{r vsnBatch}
batch <- data.frame(sample=paste(rep(names(cluster), each=2), c("Basal", "Stim"), sep="_"), 
        cluster=rep(cluster, each=2), treatment=c("Basal", "Stim"), stringsAsFactors=FALSE)
sig.raw <- acast(sig.data.raw, formula=probe ~ sample + treatment, 
		value.var="intensity")
colnames(sig.raw) <- sub("_._", "_", colnames(sig.raw))
sig.raw <- sig.raw[, batch$sample]

vsnFit <- vector(mode="list", max(batch$cluster))
sig.data.norm <- vector(mode="list", max(batch$cluster))
for(i in 1:max(batch$cluster)){
	vsnFit[[i]] <- vsn2(sig.raw[, batch$cluster==i])
	sig.data.norm[[i]] <- predict(vsnFit[[i]], newdata=sig.raw[, batch$cluster==i], 
			useDataInFit = TRUE)
}
sig.data.norm <- do.call(cbind, sig.data.norm)
```

```{r vsnBatchFit, cache=FALSE, results="hide", fig.cap=figRef("vsnBatchFit", "VSN fits to grouped dataset.")}
par(mfrow=c(2,3))
mapply(meanSdPlot, vsnFit, main=paste("Cluster", 1:max(batch$cluster)), MoreArgs=list(ylim=c(0,3)))
par(mfrow=c(1,1))
```

```{r combat}
batch <- batch[order(batch$cluster), ]
sig.data.norm <- ComBat(sig.data.norm, batch=batch$cluster, 
		mod=model.matrix(~treatment, data=batch))
```

```{r vsnPCA3, ref.label="vsnPCA"}
```

```{r combatPCAplot, cache=FALSE, fig.cap=figRef("combatPCA", "PCA plot of ComBat corrected gene expression.")}
ggplot(sig.pc, aes(x=PC1, y=PC2)) +  
     geom_point(aes( colour=as.character(Sentrix_ID)), size=3) + 
     theme_bw() + scale_colour_discrete("BeadChip")
```

```{r writeExpr}
exprOut <- gzfile("/analysis/tmp/heatshock_expr_norm.tab.gz", open="w")
write.table(sig.data.norm, file=exprOut, quote=FALSE)
```

```{r compressData, cache=FALSE}
system("tar -czf tmp/yri_geno.tar.gz tmp/hapmap_yri.smpl_flt2.bed tmp/hapmap_yri.smpl_flt2.bim tmp/hapmap_yri.smpl_flt2.fam")
```

## Differential expression analysis

All remaining samples were analysed for differences in gene expression between the basal
stimulated states, pairing samples from the same individual, using the *limma* 
Bioconductor package [@Ritchie15].

```{r limma}
labels <- strsplit(colnames(sig.data.norm), "_")
sample <- factor(sapply(labels, "[[", 1))
state <- factor(sapply(labels, "[[", 2), levels=c("Basal", "Stim"))
design <- model.matrix(~sample+state)
fit <- lmFit(sig.data.norm, design)
fit <- contrasts.fit(fit, coefficients="stateStim")
fit <- eBayes(fit)
limmaTable <- topTable(fit, n=length(fit$coefficients))
```

Individual probes were associated with corresponding genes using the updated
annotations provided by the *illuminaHumanv3.db* Bioconductor package [@Barbosa10].

```{r annotateTable}
limmaTable <- cbind(ArrayAddress=rownames(limmaTable), limmaTable)
limmaTable <- inner_join(dplyr::select(annot, ArrayAddress, NuID, SymbolReannotated, GenomicLocation),
		limmaTable)
limmaTable <- limmaTable[order(limmaTable$P.Value),]
```

# Results
## Differential expression analysis

In total `r nrow(filter(limmaTable, adj.P.Val < 0.01))` probes are identified
as differentially expressed at a p-value threshold of 0.01 (see `r tabRef("topTable")`
for the top 20 results). `r figRef("volcano")` rows a smoothed volcano plot with probes of
particular interest highlighted. 

```{r limmaResult, cache=FALSE}
set.caption(tabRef("topTable", "Top 20 differentially expressed probes."))
rownames(limmaTable) <- NULL
pander(head(dplyr::select(limmaTable, -ArrayAddress), 20))
```

```{r limmaPlot, cache=FALSE, fig.cap=figRef("volcano", "Volcano plot of differential expression results. Probes with an adjusted p-value below 0.01 and a log fold cange of at least 0.5 are shown as yellow and red dots. Probes showing particularly strong evidence of gene expression through a combination of p-value and fold change are labelled with the corresponding gene symbol.")}
fcScale <- max(-log10(limmaTable$adj.P.Val))/max(abs(limmaTable$logFC))
limmaExtreme <- subset(limmaTable, abs(logFC) > 0.5 & adj.P.Val < 0.01)
limmaExtreme <- mutate(limmaExtreme, distance=(fcScale*logFC)^2 + log10(adj.P.Val)^2)
limmaExtreme <- limmaExtreme[order(limmaExtreme$distance, decreasing=TRUE), ]
ggplot(limmaTable, aes(x=logFC, y=-log10(adj.P.Val))) + 
		stat_density2d(geom="tile", aes(fill=..density..^0.1), contour=FALSE) + 
		geom_point(data=limmaExtreme, size=1.5, aes(colour=distance)) +
		geom_text(data=subset(limmaExtreme, abs(logFC) > 0.5 & distance > 350), 
				aes(label=SymbolReannotated), vjust=0, hjust=0, angle=30) +
		stat_function(fun=function(x, scale, limit, pvalLimit, fcLimit){
					y <- ifelse(!(x >= 0 & x < fcLimit) & !(x <= 0 & x > -fcLimit), 
						(limit - (scale*x)^2)^0.5, 
						Inf)
					y <- ifelse(y < -log10(pvalLimit), Inf, y)
					y <- ifelse(is.na(y), -log10(pvalLimit), y)
				}, 
				args=list(limit=350, scale=fcScale, pvalLimit=0.01, fcLimit=0.5), linetype="dashed") +
		geom_line(data=data.frame(x=c(-Inf, -0.5), y=c(2, 2)), aes(x=x, y=y), linetype="dotted") +
		geom_line(data=data.frame(x=c(0.5, Inf), y=c(2, 2)), aes(x=x, y=y), linetype="dotted") +
		geom_line(data=data.frame(x=c(0.5, 0.5), y=c(2, Inf)), aes(x=x, y=y), linetype="dotted") +
		geom_line(data=data.frame(x=c(-0.5, -0.5), y=c(2, Inf)), aes(x=x, y=y), linetype="dotted") +
		scale_fill_gradientn(colours = colorRampPalette(c("white", blues9))(256), breaks=NULL) +
		scale_colour_gradientn(colours = colorRampPalette(c("yellow", "red"))(256), guide="none") +
		theme_bw() + xlab("log(fold change)") + ylab("-log(p-value)") + expand_limits(x=max(limmaTable$logFC)+0.25, 
            y=max(-log10(limmaTable$adj.P.Val))+2)
```

# Appendix {-}
## Custom functions used
```{r, ref.label="functions", eval=FALSE, echo=TRUE}
```

## Session Info
```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References {-}
