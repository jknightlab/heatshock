---
title: Genome-wide analysis of heat shock response 
author: 
  - name: Peter Humburg
    affiliation: Wellcome Trust Centre for Human Genetics, University of Oxford, Roosevelt Dr., Oxford, OX3 7BN, UK
    email: peter.humburg@well.ox.ac.uk
date: "`r format(Sys.time(), '%a %d %b %Y')`"
output:
  pdf_document:
    includes:
      in_header: include/captions.tex
    toc: true
    fig_caption: true
    highlight: tango
    template: include/report.latex
    pandoc_args: ["--filter=/analysis/include/hidden-print.py"]
  knitrBootstrap::bootstrap_document:
    includes:
     in_header:  include/report.css
    title: Genome-wide analysis of heat shock response
    highlight: github 
    theme.chooser: true
    highlight.chooser: true
    toc: true
    fig_caption: true
    pandoc_args: ["--filter=/analysis/include/go-link.py"]
bibliography: include/references.bib
geometry: margin=2cm
documentclass: report
classoption: a4paper
---

```{r, setup, include=FALSE, cache=FALSE}
library(MASS)
library(proto)
library(gdata)
library(affy)
library(vsn)
library(limma)
library(scatterplot3d)
library(sva)
library(ggplot2)
library(dplyr)
library(tidyr)
library(readr)
library(stringr)
library(illuminaHumanv3.db)
library(knitr)
library(pander)
library(reshape2)
library(ggdendro)
library(topGO)
library(SNPlocs.Hsapiens.dbSNP142.GRCh37)
library(plink2R)
library(MatrixEQTL)

opts_chunk$set(autodep=TRUE)
opts_chunk$set(tidy=TRUE)
opts_chunk$set(echo=TRUE)
opts_chunk$set(cache=TRUE)
opts_chunk$set(fig.width=8, fig.height=8, dpi=300)
opts_chunk$set(bootstrap.type="button")
opts_chunk$set(bootstrap.show.code=FALSE,
		bootstrap.show.output=FALSE,
		bootstrap.show.message=FALSE,
		bootstrap.show.warning=FALSE,
		bootstrap.show.error=TRUE)
panderOptions("digits", 3)
panderOptions("table.split.table", 160)
options(figcap.prefix = "Figure", figcap.sep = ":", figcap.prefix.highlight = "**")
options(tabcap.prefix = "Table", tabcap.sep = ":", tabcap.prefix.highlight = "**")
```


```{r, functions, include=FALSE}
reshapeData <- function(data, value){
	ans <- reshape2::melt(data, id.vars="probe",
		value.name=value, variable.name="sample")
	splitLabel <- strsplit(as.character(ans$sample), "_", fixed=TRUE)
	ans$sample <- sapply(splitLabel, "[", 1)
	ans$treatment <- sapply(splitLabel, function(x) x[length(x)])
	as.tbl(ans[c("sample", "treatment", "probe", value)])
}

ibsClust <- function(genome, ...){
	dst <- spread(dplyr::select(genome, IID1, IID2, DST), IID2, DST)
	size <- nrow(dst) + 1
	labels <- c(as.character(dst$IID1[1]), names(dst)[-1])
	dst <- t(1 - as.matrix(dst[-1]))
	dst <- dst[!is.na(dst)]
	attr(dst, "Size") <- size
	attr(dst, "Labels") <- labels
	attr(dst, "Diag") <- FALSE
	attr(dst, "Upper") <- FALSE
	class(dst) <- "dist"
	
	hclust(dst, ...)
}

pcaClusterPlot <- function(data, i, j, fillColour, legend=TRUE){
    data <- data[, c("sample", paste0("PC", i), paste0("PC", j), "Sentrix_ID", "cluster")]
    names(data) <- c("sample", "x", "y", "Sentrix_ID", "cluster")
    clusters <- by(data, data$cluster, function(x) x)
    fig <- ggplot(data, aes(x=x, y=y))
    for(cl in clusters){
        ch <- chull(cl$x, cl$y)
        fig <- fig + geom_polygon(data=cl[ch,], fill=fillColour[cl$cluster[1]], alpha=0.7)
    }
    fig <- fig + geom_point(aes(colour=as.character(Sentrix_ID)), size=3) +
            theme_bw() + scale_colour_discrete("BeadChip") + xlab(paste0("PC", i)) + ylab(paste0("PC", j))
    if(!legend) fig <- fig + theme(legend.position="none")
    fig
}

adjustLabel <- function(x, y, centre){
	just <- c(h=0, v=0)
	if(x < centre[1]){
		just["h"] <- just["h"] + 0.9
	} 
	if(y < centre[2]){
		just["v"] <- just["v"] + 1
	}
	just
}

## Create a scatter plot with one panel per group (by default BeadChip)
## Data points (by default samples in PC space) are assumed to be from a 
## bivariate t distribution. Confidence ellipses are drawn based on this
## (at a 95% level by default) and points outside these ellipses are marked 
## as outliers. 
outlierPlot <- function(data, x="PC1", y="PC2", group="Sentrix_ID", 
			shape="Treatment", id="Cell Line", level=0.95, ...){
	ellipses <- by(data[, c(x, y)], data[[group]], 
			function(d) tryCatch(car::dataEllipse(as.matrix(d), 
						levels=level, draw=FALSE, robust=TRUE), 
                    error=function(e) cbind(NA, NA)))
	data[[group]] <- as.character(data[[group]])
	
	names(data)[which(names(data) == x)] <- make.names(x)
	x <- make.names(x)
	names(data)[which(names(data) == y)] <- make.names(y)
	y <- make.names(y)
	names(data)[which(names(data) == group)] <- make.names(group)
	group <- make.names(group)
	names(data)[which(names(data) == shape)] <- make.names(shape)
	shape <- make.names(shape)
	names(data)[which(names(data) == id)] <- make.names(id)
	id <- make.names(id)
	
	data$outlier <- logical(nrow(data))
	for(i in 1:nrow(data)){
		data$outlier[i] <- !sp::point.in.polygon(data[i, x], data[i, y], 
				ellipses[[as.character(data[i, group])]][,1], 
				ellipses[[as.character(data[i, group])]][,2])
	}
	data$colour <- as.character(data[[group]])
	data$colour[data$outlier] <- NA
	centre <- by(data[, c(x, y)], data[[group]], colMeans)
	data$h <- if(!is.null(list(...)$hjust)) list(...)$hjust else 0
	data$v <- if(!is.null(list(...)$vjust)) list(...)$vjust else 0
	labelJust <- mapply(function(x, y, g, c) adjustLabel(x, y, c[[g]]), 
			data[[x]], data[[y]], data[[group]], MoreArgs=list(centre))
	data$h <- ifelse(labelJust["h", ] > 0, -data$h, data$h)
	data$h <- data$h + labelJust["h", ]
	data$v <- ifelse(labelJust["v", ] > 0, -data$v, data$v)
	data$v <- data$v + labelJust["v", ]			
	ggplot(data, aes_string(x=x, y=y, colour="colour")) +
			geom_point(aes_string(shape=shape), size=3) + 
			stat_ellipse(level=level) + facet_wrap(eval(parse(text=paste("~", group))), ncol=3) +
			geom_text(data=dplyr::filter(data, outlier), 
					aes_string(label=id, hjust="h", vjust="v"), size=4) +
			theme_bw() + scale_colour_discrete(guide="none")
}

# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
# author: Winston Chang ()
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

figRef <- local({
    tag <- numeric()
    created <- logical()
    used <- logical()
    function(label, caption, prefix = options("figcap.prefix"), 
        sep = options("figcap.sep"), prefix.highlight = options("figcap.prefix.highlight")) {
        i <- which(names(tag) == label)
        if (length(i) == 0) {
            i <- length(tag) + 1
            tag <<- c(tag, i)
            names(tag)[length(tag)] <<- label
            used <<- c(used, FALSE)
            names(used)[length(used)] <<- label
            created <<- c(created, FALSE)
            names(created)[length(created)] <<- label
        }
        if (!missing(caption)) {
            created[label] <<- TRUE
            paste0(prefix.highlight, prefix, " ", i, sep, prefix.highlight, 
                " ", caption)
        } else {
            used[label] <<- TRUE
            paste(prefix, tag[label])
        }
    }
})

tabRef <- local({
    tag <- numeric()
    created <- logical()
    used <- logical()
    function(label, caption, prefix = options("tabcap.prefix"), 
        sep = options("tabcap.sep"), prefix.highlight = options("tabcap.prefix.highlight")) {
        i <- which(names(tag) == label)
        if (length(i) == 0) {
            i <- length(tag) + 1
            tag <<- c(tag, i)
            names(tag)[length(tag)] <<- label
            used <<- c(used, FALSE)
            names(used)[length(used)] <<- label
            created <<- c(created, FALSE)
            names(created)[length(created)] <<- label
        }
        if (!missing(caption)) {
            created[label] <<- TRUE
            paste0(prefix.highlight, prefix, " ", i, sep, prefix.highlight, 
                " ", caption)
        } else {
            used[label] <<- TRUE
            paste(prefix, tag[label])
        }
    }
})
```

<div class="col-md-3 hidden-print hidden-xs col-sm-6 well pull-right downloads">

### Downloads {-}
#### Report
<span title="Download report as PDF">[PDF](heatshock_analysis.pdf)</span>

#### Data

```{r linkData, echo=FALSE, cache=FALSE, results="asis"}
dataFiles <- sapply(data, linkFile, "data", "markdown")
desc <- sapply(data, "[[", "desc")
cat(paste0("<span title=\"", desc, "\">", dataFiles, "</span>", collapse="<br>"))
```

#### Matrix-eQTL input

```{r linkMEQTL, echo=FALSE, cache=FALSE, results="asis"}
meqtlFiles <- sapply(matrixEQTL, linkFile, "data", "markdown")
desc <- sapply(matrixEQTL, "[[", "desc")
cat(paste0("<span title=\"", desc, "\">", meqtlFiles, "</span>", collapse="<br>"))
```


#### Log files

```{r linkLogs, echo=FALSE, cache=FALSE, results="asis"}
logFiles <- sapply(logs, linkLog, "markdown")
desc <- sapply(logs, "[[", "desc")
cat(paste0("<span title=\"", desc, "\">", logFiles, "</span>", collapse="<br>"))
```
</div>

# Introduction
The heat shock response is a highly conserved mechanism responsible for the 
maintenance of cellular function under stress. Originally identified as part of the 
response to increased environmental temperatures [@Ritossa62] heat shock proteins (HSPs) 
have since been implicated  in susceptibility to infection [@Kee08], cancer risk [@Sfar10] 
and drug response [@Martin04]. Despite its obvious significance many details of the
heat shock response still remain uncertain.

Here we study the genome-wide changes to gene expression induced by heat shock in
60 HapMap cell lines from Yoruban individuals [@Gibbs10] to identify genes and pathways
involved in the human heat shock response. To further elucidate underlying mechanisms
genetic variants modulating gene expression are mapped across all relevant genes.

# Material and Methods

## Pre-processing and Quality Control

### Raw gene expression QC

```{r loadExpression, results="hide"}
rawIntensity <- readr::read_tsv("data/TPS00590_FinalReport_12Oct09.txt", skip=8, progress=FALSE)

sig.col<-seq(3, 722, 6)
det.col<-seq(8, 722, 6)

sig.data.raw <- rawIntensity[,sig.col]
det.data.raw <- rawIntensity[,det.col]

names(sig.data.raw) <- gsub(":AVG_Signal", "", names(sig.data.raw))
names(det.data.raw) <- gsub(":Detection Pval", "", names(det.data.raw))

info<-readr::read_tsv("data/YRI_sample_list_file_03NOV09.txt", 
		col_types=list("Date of Harvest"=col_date("%d.%m.%y"), 
				"Date of RNA extraction"=col_date("%d.%m.%y")))

## remove empty lines at end of file
info<-info[1:120,] 
factors <- which(sapply(info, is.factor))
for(i in factors){
	info[[i]] <- factor(as.character(info[[i]]))
}
info[["Cell Line"]] <- sub("^GM", "NA", info[["Cell Line"]])
info[["Cell Line"]] <- sub("_.$", "", info[["Cell Line"]])
info <- mutate(info, sample=paste(`Cell Line`, `Treatment`, sep="_"))

newNames <- paste(info[["Cell Line"]], info$Treatment, sep="_")
names(newNames)<- info[["ARRAY CODE"]]

## typo in sample ID
names(sig.data.raw)[13]<- "NM-75"
names(det.data.raw)[13]<- "NM-75"

names(sig.data.raw) <-gsub("-", "_", fixed=TRUE, names(sig.data.raw))
names(det.data.raw) <-gsub("-", "_", fixed=TRUE, names(det.data.raw)) #differing name format
names(sig.data.raw) <- newNames[names(sig.data.raw)]
names(det.data.raw) <- newNames[names(det.data.raw)]

sig.data.raw <- cbind(probe=rawIntensity$ProbeID, sig.data.raw)
det.data.raw <- cbind(probe=rawIntensity$ProbeID, det.data.raw)

sig.data.log<- cbind(probe=rawIntensity$ProbeID, log2(sig.data.raw[-1]))
```
Probe intensities for resting and stimulated cells were imported into R for further
processing together with associated meta data.

```{r excludeSetup}
exclude <- list()
exclude$sample <- character()
exclude$probe <- character()
```

```{r longData}
sig.data.long <- reshapeData(sig.data.log, "intensity")
sig.data.raw.long <- reshapeData(sig.data.raw, "intensity")
det.data.long <- reshapeData(det.data.raw, "p.value")
```

Annotations for all probes were obtained via the *illuminaHumanv3.db* Bioconductor
package [@Barbosa10]. Only probes that are considered to be of perfect or good
quality were taken forward for analysis. Additionally, all probes mapping to more than
one genomic location or to a location that contains a known SNP were excluded.

```{r probeQual}
annot <- illuminaHumanv3fullReannotation() 
exclude$probe <- union(exclude$probe, subset(annot, 
		!grepl("Good|Perfect", ProbeQuality) | !is.na(OverlappingSNP) | 
		!is.na(RepeatMask))$ArrayAddress)
```

```{r thresholds}
det.pval <- 0.01
det.n <- 10
sample.missing <- 0.7
sd.min <- 0.8
```

Probes were required to exhibit significant signal (detection p-value < `r det.pval`) 
in at least `r det.n` samples and samples with less than `r (1-sample.missing)*100`% 
of the remaining probes providing significant signal were excluded 
(together with the paired sample). Samples showing exceptionally low variation in 
probe intensities (standard deviation of the log intensities of all retained probes 
below `r sd.min`) were also removed.

```{r lowDetProbe}
detected <- tally(group_by(subset(det.data.long, p.value < det.pval), probe))
exclude$probe <- union(exclude$probe, filter(detected, n < det.n)$probe)
```

```{r filterProbe}
sig.data.long <- filter(sig.data.long, !probe %in% exclude$probe)
sig.data.raw.long <- filter(sig.data.raw.long, !probe %in% exclude$probe)
det.data.long <- filter(det.data.long, !probe %in% exclude$probe)
```

```{r lowDetSample}
missingSample <- tally(group_by(filter(det.data.long, p.value > det.pval), sample, treatment))
missingSample$n <- missingSample$n/count(det.data.long, sample, treatment)$n
exclude$sample <- union(exclude$sample, filter(missingSample, n >= sample.missing)$sample)
```

```{r lowSD}
sampleSD <- summarise(group_by(filter(sig.data.long, is.finite(intensity)), 
				sample, treatment), sd(intensity))
exclude$sample <- union(exclude$sample, filter(sampleSD, `sd(intensity)` < sd.min)$sample)
```

```{r filterSample}
sig.data.long <- filter(sig.data.long, !sample %in% exclude$sample)
sig.data.raw.long <- filter(sig.data.raw.long, !sample %in% exclude$sample)
det.data.long <- filter(det.data.long, !sample %in% exclude$sample)
```

After filtering `r length(unique(sig.data.long$probe))` of `r nrow(sig.data.raw)`
probes (`r format(length(unique(sig.data.long$probe))/nrow(sig.data.raw)*100, digits=2, nsmall=1)`%)
and `r length(unique(sig.data.long$sample))` samples remain. See `r figRef("densityPlot")`
for the distributions of intensities for the remaining probes in each sample. 

```{r densityPlot, cache=FALSE, fig.cap=figRef("densityPlot", "Distribution of probe intensities.")}
ggplot(sig.data.long, aes(x=intensity, colour=sample, linetype=treatment)) + 
		geom_density() + theme_bw() + guides(colour="none")
```

```{r pcaPrepare}
flt <- filter(sig.data.long, !is.finite(intensity))$probe
sig.data.filter <- full_join(spread(filter(sig.data.long, 
					treatment == "Basal" & !probe %in% flt), 
					sample, intensity)[-1],
			spread(filter(sig.data.long, treatment == "Stim" & !probe %in% flt), 
					sample, intensity)[-1],
			by="probe")
names(sig.data.filter) <- sub(".x", "_Basal", names(sig.data.filter), fixed=TRUE)
names(sig.data.filter) <- sub(".y", "_Stim", names(sig.data.filter), fixed=TRUE)

sig.pca <- prcomp(t(sig.data.filter[-1]), scale=TRUE)
sig.pc <- as.data.frame(sig.pca$x)
sig.pc$sample <- rownames(sig.pc)
sig.pc <- dplyr::select(as.tbl(sig.pc), sample, PC1, PC2)
sig.pc <- inner_join(sig.pc, info, by="sample")

cluster <- dplyr::filter(sig.pc, `Date cRNA Amplified` != "CE_29Sep09")
clusterBound <- chull(cluster$PC1, cluster$PC2) 
```

```{r pcaPlot, cache=FALSE, fig.cap=figRef("pcaPlot", "PCA plot of probe intensities by sample. Colours correspond to different BeadChips while shapes indicate different amplification dates. Samples from the two amplifications in October 2009 are clustered together (highlighted by the grey area).")}
ggplot(sig.pc, aes(x=PC1, y=PC2)) + 
     geom_polygon(data=cluster[clusterBound, ], fill="lightgrey", colour="grey") + 
     geom_point(aes( colour=as.character(Sentrix_ID), shape=`Date cRNA Amplified`), size=3) + 
     theme_bw() + scale_colour_discrete("BeadChip") + scale_shape_discrete("RNA Amplification")
```

A principle component analysis of the gene expression for the remaining samples indicates 
a clustering of samples from two RNA amplification batches in October 2009
(`r figRef("pcaPlot")`). This batch effect is noted for later correction during the analysis.

### Genotype QC

```{r sampleList, cache=FALSE}
samples <- sub("_.", "", unique(sig.data.long$sample))
sampleInfo <- readr::read_delim("data/hapmap_YRI_r23a_filtered.fam", delim=" ", 
		col_names=c("Family", "Individual", "Father", "Mother", "Sex", "Phenotype"))
keepSamples <- dplyr::filter(dplyr::select(sampleInfo, Family, Individual), Individual %in% samples)
write.table(keepSamples, file="tmp/sample.lst", quote=FALSE, col.names=FALSE, row.names=FALSE)
```

```{r plinkSNPs, engine="bash", cache=FALSE}
plink --bfile data/hapmap_YRI_r23a_filtered --out tmp/hapmap_yri.snp_flt --keep tmp/sample.lst --maf 0.1 --geno 0.1 --hwe 1e-4 --autosome --make-bed > log/hapmap_yri.snp_flt.log
```

```{r snpFilter, cache.extra=list(file.info("data/hapmap_YRI_r23a_filtered.bim")$mtime, file.info("tmp/hapmap_yri.bim")$mtime)}
totalSNPs <- R.utils::countLines("data/hapmap_YRI_r23a_filtered.bim")
remainSNPs <- R.utils::countLines("tmp/hapmap_yri.snp_flt.bim")
```

Genotype data provided by the HapMap project [@Gibbs10] was processed with Plink [@Chang15]
to restrict the data to autosomes and remove SNPs with low genotyping rate and 
and those with a minor allele frequency of less than 10% in the sample. This results
in the exclusion of `r totalSNPs - remainSNPs` of 
`r totalSNPs` SNPs (`r format((totalSNPs - remainSNPs)/totalSNPs*100, nsmall=2, digits=2)`%);

```{r plinkSample, engine="bash", cache=FALSE}
plink --bfile tmp/hapmap_yri.snp_flt --out tmp/hapmap_yri.smpl_flt --mind 0.1 --neighbour 1 3 --genome gz nudge --make-bed > log/hapmap_yri.smpl_flt.log
```

```{r nnIBS, cache=FALSE}
nnIBS <- readr::read_table("tmp/hapmap_yri.smpl_flt.nearest")
```

The IBS nearest neighbour calculation shows that the majority of samples are quite
similar with regard to the extend of genetic differences between them while a few
show markedly increased sharing of alleles (see `r figRef("nnIBS")` and `r tabRef("nnIBS")`). 
This is consistent with a population of largely unrelated individuals including a few 
individuals that are more closely related than expected. One individual (NA18913) also shows
evidence of reduced similarity with the second and third nearest neighbour.

```{r nnIBSplot, cache=FALSE, fig.cap=figRef("nnIBS", "Similarity between individuals. For each individual the similarity, in terms of IBS, to all other individuals is determined and individuals are ranked acording to this measure. From this a Z-score is computed for for each of the three closest neighbours (see the Plink [documentation](http://pngu.mgh.harvard.edu/~purcell/plink/strat.shtml#outlier) for details). Note the spikes corresponding to individuals with positive Z-scores indicating increased similarity of their genomes compared to the rest of the cohort.")}
ggplot(nnIBS, aes(x=Z, colour=as.factor(NN))) + geom_density(aes(group=NN)) + theme_bw()
```

```{r nnIBStable, cache=FALSE}
offset <- mean(filter(nnIBS, Z < 0 & NN == 1)$Z)
nnSuspect <- filter(nnIBS, (abs(Z - offset) > 2 & NN == 1) | abs(Z) > 2)
nnSuspect <- nnSuspect[order(abs(nnSuspect$Z), decreasing=TRUE), ]
set.caption(tabRef("nnIBS", 
		"Pairs of Yoruban HapMap samples with evidence of decreased or increased genetic similarity (absolute IBS-based nearest neighbour Z-score > 2)."))
pander(nnSuspect)
```

```{r loadIBD}
ibdReport <- read.table("tmp/hapmap_yri.smpl_flt.genome.gz", header=TRUE)
ibdSD <- sd(ibdReport$PI_HAT)
ibdHigh <- dplyr::filter(ibdReport, PI_HAT > 2*ibdSD)
```

A similar picture emerges if we consider the estimated proportion of IBD for all
sample pairs with `r nrow(ibdHigh)` pairs showing evidence of higher than expected
relatedness (see `r tabRef("ibdHigh")` and `r figRef("ibsDendro")` for details).

```{r selectExlusions}
pairs <- rbind(as.matrix(dplyr::select(ibdHigh, IID1, IID2)), 
		as.matrix(dplyr::select(nnSuspect, IID, IID2)))
exSample <- character()
while(length(pairs)){
	ids <- sort(table(pairs), decreasing=TRUE)
	exSample <- c(exSample, names(ids[1]))
	pairs <- pairs[!apply(pairs, 1, `%in%`, x=names(ids)[1]), , drop=FALSE]
}
if("NA19130" %in% exSample && !"NA19192" %in% exSample){
	exSample[which(exSample == "NA19130")] <- "NA19192"
}

exclude$sample <- union(exclude$sample, exSample)
```

To ensure that at most one sample of each suspect pair are included in the analysis
the samples `r pander(exSample)` are excluded.

```{r ibdHighTab}
set.caption(tabRef("ibdHigh", paste("Sample pairs with estimated proportion of IBD exceeding",
		format(2*ibdSD, nsmall=2, digits=2))))
pander(dplyr::select(ibdHigh, IID1, IID2, PI_HAT, DST, RATIO))
```

```{r ibsDendroPlot, cache=FALSE, fig.cap=figRef("ibsDendro", "Dendrogram of individuals included in study. Distances are based on identity by state. Three pairs show clear indications of increased relatedness.")}
plot(ibsClust(ibdReport), main="", xlab="IBS", sub="")
```

```{r filterSample2, ref.label="filterSample"}
```

```{r sampleList2, ref.label="sampleList", cache=FALSE}
```

```{r plinkMdsPlot, cache=FALSE, engine="bash"}
plink --bfile tmp/hapmap_yri.smpl_flt --out tmp/hapmap_yri.smpl_flt2 --keep tmp/sample.lst --cluster --mds-plot 4 --make-bed > log/hapmap_yri.smpl_flt.log
```

```{r mdsPlot, cache=FALSE, fig.cap=figRef("mds", "MDS plot of samples remaining after genotype QC.")}
mds <- read.table("tmp/hapmap_yri.smpl_flt2.mds", header=TRUE)
ggplot(mds, aes(x=C1, y=C2)) + geom_point(size=3) + theme_bw()
```

Plotting the first two MDS components of the remaining `r nrow(keepSamples)` samples
shows no further evidence for outliers (`r figRef("mds")`).

### Normalising gene expression estimates

```{r vsn}
sig.data.norm <- justvsn(acast(sig.data.raw.long, formula=probe ~ sample + treatment, 
		value.var="intensity"))
```

```{r selectProbes}
probeMean <- rowMeans(sig.data.norm)
probeSD <- apply(sig.data.norm, 1, sd)
sig.select <- as.tbl(as.data.frame(sig.data.norm))
sig.select <- mutate(sig.select, mean=probeMean, sd=probeSD)
sig.select <- filter(sig.select, mean > 7)
sig.select <- arrange(sig.select, desc(sd), desc(mean))
sig.select <- head(sig.select, 2000)
```

```{r vsnPCA}
sig.pca <- prcomp(t(sig.select), scale=TRUE)
sig.pc <- as.data.frame(sig.pca$x)
sig.pc$sample <- rownames(sig.pc)
sig.pc <- dplyr::select(as.tbl(sig.pc), sample, PC1, PC2, PC3, PC4)
sig.pc <- inner_join(sig.pc, info, by="sample")
```

```{r vsnPCAplot, cache=FALSE, fig.cap=figRef("vsnPCA", "PCA plot of normalised gene expression estimates by sample. Each panal is comprised of the remaining samples for a singel BeadChip. For each BeadChip a 99% confidence ellipse is shown. While the majority of samples cluster well within chips some clear ouliers are visible. Variability between chips is relatively high with chips 563403730 and 563403752 appearing distinct from the bulk of the samples.")}
ggOutlier <- outlierPlot(sig.pc, level=0.985, hjust=0.2, vjust=-0.5)
sampleCount <- table(ggOutlier$data$Sentrix_ID)
excludeChip <- unique(dplyr::filter(ggOutlier$data, Sentrix_ID %in% names(sampleCount)[sampleCount <= 4])$Sentrix_ID)
outlierSample <- unique(dplyr::filter(ggOutlier$data, outlier)$Cell.Line)
chipExclusion <- unique(dplyr::filter(ggOutlier$data, Sentrix_ID %in% excludeChip)$Cell.Line)
exclude$sample <- Reduce(union, list(exclude$sample, outlierSample, chipExclusion))
ggOutlier
```

Probe intensities were normalised with VSN [@Huber02]. A PCA plot of the initial 
VSN normalised data (`r figRef("vsnPCA")`) shows clear evidence of samples
clustering by BeadChip, as well as 
`r length(outlierSample) - length(excludeChip)` 
obvious outliers, which were removed. In addition the few remaining samples from chip
`r paste(excludeChip, collapse=", ")` 
were removed as the entire chip appears to be suspect.

```{r excludeOutliers, ref.label="filterSample", dependson="vsnOutliers", cache.extra=exclude$sample}
```

```{r exclOutlGeno, ref.label="sampleList", cache=FALSE}
```

The remaining samples were normalised separately for each BeadChip and differences 
between groups corrected with ComBat [@Johnson07;@SVA15], preserving differences due to 
heat shock stimulation.

```{r vsnBatch}
batch <- with(subset(info, !`Cell Line` %in% exclude$sample), 
		data.frame(sample=sample, cluster=as.integer(factor(Sentrix_ID)), 
			treatment=Treatment, stringsAsFactors=FALSE))
sig.raw <- acast(sig.data.raw.long, formula=probe ~ sample + treatment, 
		value.var="intensity")
colnames(sig.raw) <- sub("_._", "_", colnames(sig.raw))
sig.raw <- sig.raw[, batch$sample]

vsnFit <- vector(mode="list", max(batch$cluster))
sig.data.norm <- vector(mode="list", max(batch$cluster))
for(i in 1:max(batch$cluster)){
	vsnFit[[i]] <- vsn2(sig.raw[, batch$cluster==i])
	sig.data.norm[[i]] <- predict(vsnFit[[i]], newdata=sig.raw[, batch$cluster==i], 
			useDataInFit = TRUE)
}
sig.data.norm <- do.call(cbind, sig.data.norm)
```

```{r vsnBatchFit, cache=FALSE, results="hide", fig.cap=figRef("vsnBatchFit", "VSN fits to grouped dataset.")}
par(mfrow=c(3,3))
mapply(meanSdPlot, vsnFit, main=paste("Cluster", 1:max(batch$cluster)), MoreArgs=list(ylim=c(0, 1)))
par(mfrow=c(1,1))
```

```{r combat}
batch <- batch[order(batch$cluster), ]
sig.data.norm <- sig.data.norm[, batch$sample]
sig.data.norm <- ComBat(sig.data.norm, batch=batch$cluster, 
		mod=model.matrix(~treatment, data=batch))
```

```{r combatPCA}
sig.pca <- prcomp(t(sig.data.norm), scale = TRUE)
sig.pc <- as.data.frame(sig.pca$x)
sig.pc$sample <- rownames(sig.pc)
sig.pc <- dplyr::select(as.tbl(sig.pc), sample, PC1, PC2, PC3, PC4)
sig.pc <- inner_join(sig.pc, info, by = "sample")
```

```{r combatPCAplot, cache=FALSE, fig.cap=figRef("combatPCA", "PCA plot of ComBat corrected gene expression.")}
ggplot(sig.pc, aes(x=PC1, y=PC2)) +  
     geom_point(aes( colour=as.character(Sentrix_ID)), size=3) + 
     theme_bw() + scale_colour_discrete("BeadChip")
```

```{r writeExpr, cache=FALSE}
exprOut <- gzfile("/analysis/tmp/heatshock_expr_norm.tab.gz", open="w")
write.table(sig.data.norm, file=exprOut, quote=FALSE)
close(exprOut)
```

```{r compressData, cache=FALSE}
system("tar -czf tmp/yri_geno.tar.gz tmp/hapmap_yri.smpl_flt2.bed tmp/hapmap_yri.smpl_flt2.bim tmp/hapmap_yri.smpl_flt2.fam")
```

## Differential expression analysis

All remaining samples were analysed for differences in gene expression between the basal
stimulated states, pairing samples from the same individual, using the *limma* 
Bioconductor package [@Ritchie15].

```{r limma}
labels <- strsplit(colnames(sig.data.norm), "_")
sample <- factor(sapply(labels, "[[", 1))
state <- factor(sapply(labels, "[[", 2), levels=c("Basal", "Stim"))
design <- model.matrix(~sample+state)
fit <- lmFit(sig.data.norm, design)
fit <- contrasts.fit(fit, coefficients="stateStim")
fit <- eBayes(fit)
limmaTable <- topTable(fit, n=length(fit$coefficients))
```

Individual probes were associated with corresponding genes using the updated
annotations provided by the *illuminaHumanv3.db* Bioconductor package [@Barbosa10].

```{r annotateTable}
limmaTable <- cbind(ArrayAddress=rownames(limmaTable), limmaTable)
limmaTable <- inner_join(dplyr::select(annot, ArrayAddress, NuID, SymbolReannotated, EntrezReannotated, GenomicLocation),
		limmaTable)
limmaTable <- limmaTable[order(limmaTable$P.Value),]
```

```{r writeDiffExpr, cache=FALSE}
write.table(limmaTable, file="/analysis/tmp/differential_expression.tab", row.names=FALSE, quote=FALSE, sep="\t")
```

## GO enrichment analysis

To further investigate the patterns of differential expression a GO enrichment analysis 
was carried out using the Bioconductor package *topGO* [@Alexa10]. Fisher's Exact Test
was used to determine enrichment separately for significantly (FDR < 0.01) up 
(`r tabRef("topGOUp")`) and down (`r tabRef("topGODown")`) regulated genes.

```{r preTopGO}
fdrCut <- 0.01
fcCut <- log2(1.2)
groupUp <- ifelse(limmaTable$adj.P.Val < fdrCut & limmaTable$logFC > fcCut, 1, 0)
groupDown <- ifelse(limmaTable$adj.P.Val < fdrCut & limmaTable$logFC < -fcCut, 1, 0)
groupAll <- ifelse(limmaTable$adj.P.Val < fdrCut & abs(limmaTable$logFC) > fcCut, 1, 0)

universeUp <- factor(groupUp)
names(universeUp) <- limmaTable$EntrezReannotated
universeUp <- universeUp[!is.na(names(universeUp))]
universeDown <- factor(groupDown)
names(universeDown) <- limmaTable$EntrezReannotated
universeDown <- universeDown[!is.na(names(universeDown))]
universeAll <- factor(groupAll)
names(universeAll) <- limmaTable$EntrezReannotated
universeAll <- universeAll[!is.na(names(universeAll))]

tgUp <- new("topGOdata", ontology="BP", allGenes=universeUp, nodeSize=10,
			description="Genes up-regulated after heat shock",
			annotationFun=annFUN.org, mapping="org.Hs.eg.db")
tgDown <- new("topGOdata", ontology="BP", allGenes=universeDown, nodeSize=10,
			description="Genes down-regulated after heat shock",
			annotationFun=annFUN.org, mapping="org.Hs.eg.db")
tgAny <- new("topGOdata", ontology="BP", allGenes=universeAll, nodeSize=10,
			description="Genes differentially expressed in response to heat shock",
			annotationFun=annFUN.org, mapping="org.Hs.eg.db")
```

```{r testTopGO}
resultUp <- runTest(tgUp, algorithm="classic", statistic="fisher")
resultDown <- runTest(tgDown, algorithm="classic", statistic="fisher")
```

## Response QTL analysis
All probes considered to be differentially expressed following heat shock treatment
(FDR < `r fdrCut` and fold change > `r 2^fcCut`) were further investigated for
the presence of genetic variation that modulates their response to the stimulus.

For each probe the observed response to the stimulus (as measured by the log~2~ 
fold change) is tested for association with the genotypes within a 1 Mb window
either side of the probe location. For this purpose only typed SNPs that passed
QC were considered. Only genes and SNPs on autosomes were included in the 
analysis.

```{r selectGenes}
exclChrom <- c("chrX", "chrY", "chrM")
selectedGenes <- dplyr::filter(limmaTable, adj.P.Val < fdrCut & abs(logFC) > fcCut &
                                 !str_detect(GenomicLocation, paste(exclChrom, collapse="|")))
selectedGenes <- dplyr::select(selectedGenes, ArrayAddress, NuID, GenomicLocation)

selectedGenes$GenomicLocation <- str_extract(selectedGenes$GenomicLocation, 
                                             "chr[[:digit:]]{1,2}:[[:digit:]]+:[[:digit:]]+")
selectedGenes <- dplyr::filter(selectedGenes, !is.na(GenomicLocation))
```

```{r probeFC}
selectedExpr <- sig.data.norm[selectedGenes$ArrayAddress,]
basalIdx <- grep("_Basal", colnames(selectedExpr))
stimIdx <- grep("_Stim", colnames(selectedExpr))
selectedFC <- selectedExpr[, stimIdx] - selectedExpr[, basalIdx]
colnames(selectedFC) <- str_extract(colnames(selectedFC), "NA[[:digit:]]+")
rownames(selectedFC) <- selectedGenes$NuID
```

```{r writeFcFile, cache=FALSE}
write.table(selectedFC, file="tmp/selected_probes_fc.tab", sep="\t", quote=FALSE)
```

```{r probeLoc}
probePos <- str_split_fixed(selectedGenes$GenomicLocation, ":", 3)
colnames(probePos) <- c("chrom", "start", "end")
rownames(probePos) <- selectedGenes$NuID
```

```{r writeProbePos, cache=FALSE}
write.table(probePos, file="tmp/selected_probes_pos.tab", sep="\t", quote=FALSE)
```

The GRCh37 coordinates for SNPs were obtained via the *SNPlocs.Hsapiens.dbSNP142.GRCh37*
Bioconductor package [@Pages14].

```{r snpPos}
geno <- read_plink("tmp/hapmap_yri.smpl_flt2")
geno$bim <- dplyr::select(geno$bim, 2, 1, 4)
names(geno$bim) <- c("snp", "chrom", "pos")
```

```{r snpPosUpdate}
geno$bim <- by(geno$bim, geno$bim$chrom, function(x){
  locs <- getSNPlocs(paste0("ch", x$chrom[1]), caching=FALSE)
  locs$RefSNP_id <- paste0("rs", locs$RefSNP_id)
  snps <- inner_join(x, locs, by=c(snp="RefSNP_id"))
  if(nrow(snps) < nrow(x)) warning("Dropped ", nrow(x) - nrow(snps), " SNP(s) from chromosome ", x$chrom[1])
  dplyr::select(snps, snp, chrom, loc)
})
```

```{r snpPosComb}
geno$bim <- do.call(rbind, geno$bim)
geno$bim$chrom <- paste0("chr", geno$bim$chrom)
geno$bim <- geno$bim[order(geno$bim$chrom, geno$bim$loc),]
```

```{r writeSNPpos, cache=FALSE}
write.table(geno$bim, file="tmp/snp_loc_GRCh37.tab", quote=FALSE, sep="\t")
system("gzip -c tmp/snp_loc_GRCh37.tab > tmp/snp_loc_GRCh37.tab.gz", internal=TRUE)
```

```{r prepGeno}
rownames(geno$bed) <- str_extract(rownames(geno$bed), "NA[[:digit:]]+")
geno$bed <- geno$bed[colnames(selectedFC), geno$bim$snp]
geno$bed <- t(geno$bed)
flip <- rowSums(geno$bed, na.rm=TRUE) > ncol(geno$bed)
if(any(flip)){
  geno$bed[flip, ] <- -geno$bed[flip]+2
}
```

```{r writeGeno, cache=FALSE}
write.table(geno$bed, file="tmp/genotypes_GRCh37.tab", quote=FALSE, sep="\t")
system("gzip -c tmp/genotypes_GRh37.tab > tmp/genotypes_GRCh37.tab.gz", internal=TRUE)
```

We tested for associations between genotype and heat shock response using
Matrix-eQTL [@Shabalin12]. The analysis was carried out in two stages. The
first stage served to identify genes that show evidence of being modulated 
by local genetic variation. To this end determine the the minimum p-value 
for each gene, adjusted for the number of SNPs tested for association
with this gene using a Bonferroni correction. The resulting p-values are
then corrected for the number of genes tested by computing the corresponding
false discovery rate. The second stage served to examine the identified
genes more closely by identifying individual SNPs that are associated
with the change in expression observed for the gene in response to the stimulus.
Only genes that were considered significant during the first stage were 
examined and SNP p-values were corrected for multiple testing on a per gene
basis.

```{r covariates}
geno$fam <- dplyr::filter(dplyr::select(geno$fam, 2, 5), V2 %in% colnames(geno$bed))
geno$fam <- t(geno$fam)
colnames(geno$fam) <- geno$fam[1,]
geno$fam <- geno$fam[, colnames(geno$bed)]
```

```{r writeCovar, cache=FALSE}
write.table(geno$fam[-1, , drop=FALSE], file="tmp/covariates.tab", quote=FALSE, sep="\t")
system("gzip -c tmp/covariates.tab > tmp/covariates.tab.gz", internal=TRUE)
```

```{r prepQTL}
snps <- SlicedData$new();
snps$fileDelimiter <- "\t"
snps$fileOmitCharacters <- "NA"
snps$fileSkipRows <- 1
snps$fileSkipColumns <- 1
snps$fileSliceSize <- 2000
snps$LoadFile("tmp/genotypes_GRCh37.tab")

pheno <- SlicedData$new();
pheno$fileDelimiter <- "\t"
pheno$fileOmitCharacters <- "NA"
pheno$fileSkipRows <- 1
pheno$fileSkipColumns <- 1
pheno$fileSliceSize <- 2000
pheno$LoadFile("tmp/selected_probes_fc.tab")

covar <- SlicedData$new();
covar$fileDelimiter <- "\t"
covar$fileOmitCharacters <- "NA"
covar$fileSkipRows <- 1
covar$fileSkipColumns <- 1
covar$fileSliceSize <- 2000
covar$LoadFile("tmp/covariates.tab")
```

# Results
## Differential expression analysis

In total `r nrow(filter(limmaTable, adj.P.Val < fdrCut))` probes are identified
as differentially expressed at an FDR threshold of `r fdrCut` (see `r tabRef("topTable")`
for the top 20 results). Of these `r nrow(filter(limmaTable, adj.P.Val < fdrCut & logFC > 0))` 
are up and `r nrow(filter(limmaTable, adj.P.Val < fdrCut & logFC < 0))` down regulated
following heat shock treatment. Further restricting this list by excluding all probes with a 
fold change of less than `r 2^fcCut` leaves `r nrow(filter(limmaTable, adj.P.Val < fdrCut & abs(logFC) > fcCut))` 
probes with `r nrow(filter(limmaTable, adj.P.Val < fdrCut & logFC > fcCut))` and 
`r nrow(filter(limmaTable, adj.P.Val < fdrCut & logFC < -fcCut))` up and down regulated respectively. 
`r figRef("volcano")` shows a smoothed volcano plot highlighting probes of particular interest. 

```{r limmaResult, cache=FALSE}
set.caption(tabRef("topTable", "Top 20 differentially expressed probes."))
rownames(limmaTable) <- NULL
pander(head(dplyr::select(limmaTable, -ArrayAddress, -EntrezReannotated, -GenomicLocation), 20))
```

```{r limmaPlot, cache=FALSE, fig.cap=figRef("volcano", "Volcano plot of differential expression results. Probes with an adjusted p-value below 0.01 and a log fold cange of at least 0.5 are shown as yellow and red dots. Probes showing particularly strong evidence of changes in gene expression through a combination of p-value and fold change are labelled with the corresponding gene symbol.")}
fcCut2 <- log2(2)   ## label all genes with logFC greater than this
fcScale <- max(-log10(limmaTable$adj.P.Val))/max(abs(limmaTable$logFC))
limmaExtreme <- dplyr::filter(limmaTable, abs(logFC) > fcCut & adj.P.Val < fdrCut)
limmaExtreme <- mutate(limmaExtreme, distance=(fcScale*logFC)^2 + log10(adj.P.Val)^2)
limmaExtreme <- limmaExtreme[order(limmaExtreme$distance, decreasing=TRUE), ]
ggplot(limmaTable, aes(x=logFC, y=-log10(adj.P.Val))) + 
        stat_density2d(data=dplyr::filter(limmaTable, abs(logFC) <= fcCut | adj.P.Val >= fdrCut),
                      geom="tile", aes(fill=..density..^0.1), contour=FALSE) + 
        geom_point(data=limmaExtreme, size=1.5, aes(colour=distance)) +
        geom_text(data=dplyr::filter(limmaExtreme, distance > (2*fcScale)^2 & logFC >= fcCut2), 
                aes(label=SymbolReannotated), vjust=0, hjust=0, angle=30) +
        geom_text(data=dplyr::filter(limmaExtreme, distance > (2*fcScale)^2 & logFC <= -fcCut2), 
                aes(label=SymbolReannotated), vjust=0, hjust=1, angle=330) +
        geom_line(data=data.frame(x=c(-Inf, -fcCut), y=c(-log10(fdrCut), -log10(fdrCut))), 
        		aes(x=x, y=y), linetype="dotted") +
        geom_line(data=data.frame(x=c(fcCut, Inf), 
        		y=c(-log10(fdrCut), -log10(fdrCut))), aes(x=x, y=y), linetype="dotted") +
        geom_line(data=data.frame(x=c(fcCut, fcCut), y=c(-log10(fdrCut), Inf)), 
        		aes(x=x, y=y), linetype="dotted") +
        geom_line(data=data.frame(x=c(-fcCut, -fcCut), y=c(-log10(fdrCut), Inf)), 
        		aes(x=x, y=y), linetype="dotted") +
        scale_fill_gradientn(colours = colorRampPalette(c("white", blues9))(256), breaks=NULL) +
        scale_colour_gradientn(colours = colorRampPalette(c("yellow", "red"))(256), 
        		guide="none") +
        theme_bw() + xlab("log2(fold change)") + ylab("-log10(FDR)") + 
        expand_limits(x=c(min(limmaTable$logFC)-0.25, max(limmaTable$logFC)+0.25), 
            y=max(-log10(limmaTable$adj.P.Val))+2)
```

## GO enrichment analysis
The GO analysis highlights several categories that are significantly enriched among
the up and down regulated genes (`r sum(score(resultUp) < 0.01)` and 
`r sum(score(resultDown) < 0.01)` categories with a p-value < 0.01 respectively).
Considering the top categories (`r tabRef("topGOUp")` and `r tabRef("topGODown")`)
it appears that genes up regulated in response to heat shock are predominantly
related to stress response (including *response to heat* [GO:0009408]) 
and protein folding (including *response to unfolded protein* [GO:0006986] and 
*protein refolding* [GO:0042026]) whereas down regulated genes
broadly relate to cell proliferation and normal lymphocyte function and 
include *positive regulation of cell cycle* [GO:0045787], *spindle assembly* [GO:0051225]
and *chemokine production* [GO:0032602].

```{r tableTopGOUp, chache=FALSE}
set.caption(tabRef("topGOUp", "Top 20 GO categories enriched for up regulated genes."))
pander(GenTable(tgUp, up=resultUp, down=resultDown, topNodes=20, orderBy="up"))
```

```{r tableTopGODown, chache=FALSE}
set.caption(tabRef("topGODown", "Top 20 GO categories enriched for down regulated genes"))
pander(GenTable(tgDown, down=resultDown, up=resultUp, topNodes=20, orderBy="down"))
```

```{r goPlot, cache=FALSE, fig.width=10, fig.height=6, fig.cap=figRef("goPlot", "GO category enrichment for differentially expressed genes.")}
tblUp <- GenTable(tgUp, up=resultUp, topNodes=length(score(resultUp)))
tblUp$up <- as.numeric(tblUp$up)
tblDown <- GenTable(tgDown, down=resultDown, topNodes=length(score(resultDown)))
tblDown$down <- as.numeric(tblDown$down)
tbl <- bind_rows(gather(tblUp, "direction", "p.value", up), gather(tblDown, "direction", "p.value", down))
ggplot(tbl, aes(x=Expected, y=Significant)) + 
    geom_point(data=dplyr::filter(tbl, p.value >= 1e-4), colour="grey") +
    geom_point(data=dplyr::filter(tbl, p.value < 1e-4), aes(fill=-log10(p.value), shape=direction), 
        size=2.5) +
    geom_abline(intercept=0, slope=1) +
    scale_shape_manual(values=c(up=24, down=25)) +
    theme_bw()
```


# Appendix {-}
## Custom functions used
```{r, ref.label="functions", eval=FALSE, echo=TRUE}
```

## Session Info
```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References {-}
